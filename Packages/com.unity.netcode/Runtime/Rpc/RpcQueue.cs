using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;

namespace Unity.NetCode
{
    /// <summary>
    /// <para>
    /// A helper struct that should be used schedule outgoing RPCs.
    /// The RpcQueue is used internally by the code-generated systems that consume the
    /// <see cref="SendRpcCommandRequest"/> requests, and allow you to serialize the rpc (that will be sent
    /// into the <see cref="OutgoingRpcDataStreamBuffer"/> for the outgoing connection).
    /// </para>
    /// <para>
    /// You can use the RpcQueue in your custom system by retrieving an instance for the given
    /// <typeparamref name="TActionRequest"/>, <typeparamref name="TActionSerializer"/> pair from the <see cref="RpcCollection"/>
    /// by calling the <see cref="RpcCollection.GetRpcQueue{TActionRequest,TActionSerializer}"/> method.
    /// </para>
    /// <para>
    /// <typeparam name="TActionSerializer">The typename of the struct implementing the <see cref="IRpcCommandSerializer{T}"/> interface
    /// for the <typeparamref name="TActionRequest"/> </typeparam>
    /// <typeparam name="TActionRequest">The typename of a struct implementing the <see cref="IComponentData"/> interface</typeparam>
    /// </para>
    /// </summary>
    /// <remarks>
    /// If you intend to cache the retrieved queue (e.g. inside an OnCreate function in your system),
    /// you must ensure that your system is created after the <see cref="RpcSystem"/> by using the <see cref="CreateAfterAttribute"/>.
    /// </remarks>
    /// <typeparam name="TActionSerializer">the struct type that implements the IRpcCommandSerializer interface.</typeparam>
    /// <typeparam name="TActionRequest">the rpc type</typeparam>
    public struct RpcQueue<TActionSerializer, TActionRequest>
        where TActionRequest : struct, IComponentData
        where TActionSerializer : struct, IRpcCommandSerializer<TActionRequest>
    {
        internal ulong rpcType;
        [ReadOnly] internal NativeParallelHashMap<ulong, int> rpcTypeHashToIndex;
        [ReadOnly] internal NativeReference<byte> dynamicAssemblyList;

        /// <summary>
        /// <para>
        /// Schedules an rpc to be sent through the network, by serializing and appending a new
        /// rpc packet into the <see cref="OutgoingRpcDataStreamBuffer"/>, for the given connection.
        /// </para>
        /// <para>
        /// The binary rpc data has the following format:</para>
        /// <para> - PacketType: short or long based on the <see cref="RpcCollection.DynamicAssemblyList"/>.</para>
        /// <para> - MsgLen: short, the length of the serialized data.</para>
        /// <para> - RpcData: the binary data generated by invoking the <typeparamref name="TActionSerializer"/> serialize method.</para>
        /// </summary>
        /// <param name="buffer"></param>
        /// <param name="ghostFromEntity"></param>
        /// <param name="data"></param>
        /// <exception cref="InvalidOperationException"></exception>
        public unsafe void Schedule(DynamicBuffer<OutgoingRpcDataStreamBuffer> buffer,
            ComponentLookup<GhostInstance> ghostFromEntity, TActionRequest data)
        {
            var serializer = default(TActionSerializer);
            var serializerState = new RpcSerializerState {GhostFromEntity = ghostFromEntity};
            var msgHeaderLen = dynamicAssemblyList.Value == 1 ? 10 : 4;
            int maxSize = UnsafeUtility.SizeOf<TActionRequest>() + msgHeaderLen + 1;
            int rpcIndex = 0;
            if (!(dynamicAssemblyList.Value == 1) && !rpcTypeHashToIndex.TryGetValue(rpcType, out rpcIndex))
                throw new InvalidOperationException("Could not find RPC index for type");
            while (true)
            {
                DataStreamWriter writer = new DataStreamWriter(maxSize, Allocator.Temp);
                if (dynamicAssemblyList.Value == 1)
                    writer.WriteULong(rpcType);
                else
                    writer.WriteUShort((ushort)rpcIndex);
                var lenWriter = writer;
                writer.WriteUShort((ushort)0);
                serializer.Serialize(ref writer, serializerState, data);
                if (!writer.HasFailedWrites)
                {
                    if (writer.Length > ushort.MaxValue)
                        throw new InvalidOperationException("RPC is too large to serialize");
                    lenWriter.WriteUShort((ushort)(writer.Length - msgHeaderLen));
                    var prevLen = buffer.Length;
                    buffer.ResizeUninitialized(buffer.Length + writer.Length);
                    byte* ptr = (byte*) buffer.GetUnsafePtr();
                    ptr += prevLen;
                    UnsafeUtility.MemCpy(ptr, writer.AsNativeArray().GetUnsafeReadOnlyPtr(), writer.Length);
                    break;
                }
                maxSize *= 2;
            }
        }
    }
}
