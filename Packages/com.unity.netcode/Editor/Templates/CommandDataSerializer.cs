// THIS FILE IS AUTO-GENERATED BY NETCODE PACKAGE SOURCE GENERATORS. DO NOT DELETE, MOVE, COPY, MODIFY, OR COMMIT THIS FILE.
// TO MAKE CHANGES TO THE SERIALIZATION OF A TYPE, REFER TO THE MANUAL.
using Unity.Burst;
using Unity.Burst.Intrinsics;
using Unity.Collections.LowLevel.Unsafe;
using System.Runtime.CompilerServices;
#region __COMMAND_USING_STATEMENT__
using __COMMAND_USING__;
#endregion


namespace __COMMAND_NAMESPACE__
{
    [System.Runtime.CompilerServices.CompilerGenerated]
    internal struct __COMMAND_NAME__Serializer : ICommandDataSerializer<__COMMAND_COMPONENT_TYPE__>
    {
        public void Serialize(ref DataStreamWriter writer, in RpcSerializerState state, in __COMMAND_COMPONENT_TYPE__ data)
        {
            #region __COMMAND_WRITE__
            #endregion
        }

        public void Deserialize(ref DataStreamReader reader, in RpcDeserializerState state, ref __COMMAND_COMPONENT_TYPE__ data)
        {
            #region __COMMAND_READ__
            #endregion
        }

        public void Serialize(ref DataStreamWriter writer, in RpcSerializerState state, in __COMMAND_COMPONENT_TYPE__ data, in __COMMAND_COMPONENT_TYPE__ baseline, StreamCompressionModel compressionModel)
        {
            #region __COMMAND_WRITE_PACKED__
            #endregion
        }

        public void Deserialize(ref DataStreamReader reader, in RpcDeserializerState state, ref __COMMAND_COMPONENT_TYPE__ data, in __COMMAND_COMPONENT_TYPE__ baseline, StreamCompressionModel compressionModel)
        {
            #region __COMMAND_READ_PACKED__
            #endregion
        }
    }

    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(CommandSendSystemGroup))]
    [BurstCompile]
    internal partial struct __COMMAND_NAME__SendCommandSystem : ISystem
    {
        CommandSendSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__> m_CommandSend;
        [BurstCompile]
        struct SendJob : IJobChunk
        {
            public CommandSendSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__>.SendJobData data;
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                data.Execute(chunk, unfilteredChunkIndex);
            }
        }
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_CommandSend.OnCreate(ref state);
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            if (!m_CommandSend.ShouldRunCommandJob(ref state))
                return;
            var sendJob = new SendJob{data = m_CommandSend.InitJobData(ref state)};
            state.Dependency = sendJob.Schedule(m_CommandSend.Query, state.Dependency);
        }
    }

    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(CommandReceiveSystemGroup))]
    [BurstCompile]
    internal partial struct __COMMAND_NAME__ReceiveCommandSystem : ISystem
    {
        CommandReceiveSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__> m_CommandRecv;
        [BurstCompile]
        struct ReceiveJob : IJobChunk
        {
            public CommandReceiveSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__>.ReceiveJobData data;
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                data.Execute(chunk, unfilteredChunkIndex);
            }
        }
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_CommandRecv.OnCreate(ref state);
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            var recvJob = new ReceiveJob{data = m_CommandRecv.InitJobData(ref state)};
            state.Dependency = recvJob.Schedule(m_CommandRecv.Query, state.Dependency);
        }
    }

    [UpdateInGroup(typeof(CompareCommandSystemGroup))]
    [BurstCompile]
    [System.Runtime.CompilerServices.CompilerGenerated]
    internal partial struct __COMMAND_NAME__CompareCommandSystem : ISystem
    {
        [BurstCompile]
        struct CompareJob : IJobChunk
        {
            public NativeParallelHashMap<NetworkTick,NetworkTick>.ParallelWriter map;
            [ReadOnly] public BufferTypeHandle<__COMMAND_COMPONENT_TYPE__> inputTypeHandle;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            private static uint Compare(in __COMMAND_COMPONENT_TYPE__ snapshot, in __COMMAND_COMPONENT_TYPE__ baseline)
            {
                uint changeMask = 0;
                #region __GHOST_COMPARE_INPUTS__
                #endregion
                return changeMask;
            }

            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                var inputBufferAccessor = chunk.GetBufferAccessor(ref inputTypeHandle);
                for (int entIdx = 0; entIdx < chunk.Count; ++entIdx)
                {
                    var inputBuffer = inputBufferAccessor[entIdx];
                    var length = inputBuffer.Length;
                    //The buffer can be in two state:
                    //1,2,3,4,5,6... 64 (all ordered)
                    //64+1,64+2,64+3,64+4,64+5,6,8,12,10,...64 // split state.
                    //This is also a search done on the client side. That store the input constantly in increasing bucket order.
                    //That imply it is more logic to start the comparison from the "oldest" input and going forward.
                    //Or start from the newest and going backward. We are using the latter.
                    for (int i = 0; i < length; ++i)
                    {
                        ref readonly var curInput = ref inputBuffer.GetInputAtIndex(i);
                        var curTick = curInput.Tick;
                        //We can also stop to the first invalid tick. Because tick are invalid only if the buffer is not full yet.
                        if (!curTick.IsValid)
                            break;
                        var prevTick = curInput.Tick;
                        prevTick.Decrement();
                        //There is not need to search. We know that this is going to be the previous element in the buffer.
                        var beforeIdx = (i - 1 + length) % length;
                        //We can stop as soon as we find the first element that is less than or equal the tick
                        //or that is invalid
                        ref readonly var prevInput = ref inputBuffer.GetInputAtIndex(beforeIdx);
                        //This check requires some explanation. We need to determine if the previous slot is the head of the buffer.
                        //Two cases:
                        //1) prevInput.Tick <= prevTick (considering overlap)
                        //2) prevInput.Tick > prevTick (considering overlap)
                        //if the prevInput is the "head" of the input buffer there cannot be input with a tick less thab prevTick and
                        //we can stop the run.
                        //if the prevInput is <= prevTick we need to check if they are identical.
                        if (!prevInput.Tick.IsValid || prevInput.Tick.IsNewerThan(prevTick) || Compare(curInput, prevInput) != 0)
                            map.TryAdd(curTick, curTick);
                    }
                }
            }
        }
        private EntityQuery m_Query;
        private EntityQuery m_TickMapQuery;
        private BufferTypeHandle<__COMMAND_COMPONENT_TYPE__> m___COMMAND_NAME__Handle;
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            var builder = new EntityQueryBuilder(Allocator.Temp)
                .WithAllRW<__COMMAND_COMPONENT_TYPE__>();
            m_Query = state.GetEntityQuery(builder);
            builder.Reset();
            builder.WithAllRW<UniqueInputTickMap>();
            m_TickMapQuery = state.GetEntityQuery(builder);
            m___COMMAND_NAME__Handle = state.GetBufferTypeHandle<__COMMAND_COMPONENT_TYPE__>(true);
            state.RequireForUpdate(m_Query);
            state.RequireForUpdate<UniqueInputTickMap>();
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            m___COMMAND_NAME__Handle.Update(ref state);
            var job = new CompareJob
            {
                inputTypeHandle = m___COMMAND_NAME__Handle,
                map = m_TickMapQuery.GetSingletonRW<UniqueInputTickMap>().ValueRW.Value
            };
            state.Dependency = job.ScheduleParallel(m_Query, state.Dependency);
        }
    }
}
