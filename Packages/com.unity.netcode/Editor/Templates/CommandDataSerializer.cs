// THIS FILE IS AUTO-GENERATED BY NETCODE PACKAGE SOURCE GENERATORS. DO NOT DELETE, MOVE, COPY, MODIFY, OR COMMIT THIS FILE.
// TO MAKE CHANGES TO THE SERIALIZATION OF A TYPE, REFER TO THE MANUAL.
using AOT;
using Unity.Burst;
using Unity.Burst.Intrinsics;
using Unity.Collections.LowLevel.Unsafe;
#region __COMMAND_USING_STATEMENT__
using __COMMAND_USING__;
#endregion


namespace __COMMAND_NAMESPACE__
{
    [System.Runtime.CompilerServices.CompilerGenerated]
    internal struct __COMMAND_NAME__Serializer : ICommandDataSerializer<__COMMAND_COMPONENT_TYPE__>
    {
        public void Serialize(ref DataStreamWriter writer, in RpcSerializerState state, in __COMMAND_COMPONENT_TYPE__ data)
        {
            #region __COMMAND_WRITE__
            #endregion
        }

        public void Deserialize(ref DataStreamReader reader, in RpcDeserializerState state, ref __COMMAND_COMPONENT_TYPE__ data)
        {
            #region __COMMAND_READ__
            #endregion
        }

        public void Serialize(ref DataStreamWriter writer, in RpcSerializerState state, in __COMMAND_COMPONENT_TYPE__ data, in __COMMAND_COMPONENT_TYPE__ baseline, StreamCompressionModel compressionModel)
        {
            #region __COMMAND_WRITE_PACKED__
            #endregion
        }

        public void Deserialize(ref DataStreamReader reader, in RpcDeserializerState state, ref __COMMAND_COMPONENT_TYPE__ data, in __COMMAND_COMPONENT_TYPE__ baseline, StreamCompressionModel compressionModel)
        {
            #region __COMMAND_READ_PACKED__
            #endregion
        }
    }

    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(CommandSendSystemGroup))]
    [BurstCompile]
    internal partial struct __COMMAND_NAME__SendCommandSystem : ISystem
    {
        CommandSendSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__> m_CommandSend;
        [BurstCompile]
        struct SendJob : IJobChunk
        {
            public CommandSendSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__>.SendJobData data;
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                data.Execute(chunk, unfilteredChunkIndex);
            }
        }
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_CommandSend.OnCreate(ref state);
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            if (!m_CommandSend.ShouldRunCommandJob(ref state))
                return;
            var sendJob = new SendJob{data = m_CommandSend.InitJobData(ref state)};
            state.Dependency = sendJob.Schedule(m_CommandSend.Query, state.Dependency);
        }
    }

    [System.Runtime.CompilerServices.CompilerGenerated]
    [UpdateInGroup(typeof(CommandReceiveSystemGroup))]
    [BurstCompile]
    internal partial struct __COMMAND_NAME__ReceiveCommandSystem : ISystem
    {
        CommandReceiveSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__> m_CommandRecv;
        [BurstCompile]
        struct ReceiveJob : IJobChunk
        {
            public CommandReceiveSystem<__COMMAND_NAME__Serializer, __COMMAND_COMPONENT_TYPE__>.ReceiveJobData data;
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                data.Execute(chunk, unfilteredChunkIndex);
            }
        }
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            m_CommandRecv.OnCreate(ref state);
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            var recvJob = new ReceiveJob{data = m_CommandRecv.InitJobData(ref state)};
            state.Dependency = recvJob.Schedule(m_CommandRecv.Query, state.Dependency);
        }
    }

    [UpdateInGroup(typeof(CompareCommandSystemGroup))]
    [BurstCompile]
    [System.Runtime.CompilerServices.CompilerGenerated]
    internal partial struct __COMMAND_NAME__CompareCommandSystem : ISystem
    {
        [BurstCompile]
        struct CompareJob : IJobChunk
        {
            public NativeParallelHashMap<NetworkTick,NetworkTick>.ParallelWriter map;
            [ReadOnly] public BufferTypeHandle<__COMMAND_COMPONENT_TYPE__> inputHandle;
            public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask, in v128 chunkEnabledMask)
            {
                var inputBufferAccessor = chunk.GetBufferAccessor(ref inputHandle);
                for (int entIdx = 0; entIdx < chunk.Count; ++entIdx)
                {
                    var inputBuffer = inputBufferAccessor[entIdx];
                    for (int i = 0 ; i < inputBuffer.Length; ++i)
                    {
                        var curInput = inputBuffer[i];
                        if (!curInput.Tick.IsValid)
                            continue;
                        var prevTick = curInput.Tick;
                        prevTick.Decrement();
                        if (!inputBuffer.GetDataAtTick(prevTick, out var prevInput))
                        {
                            map.TryAdd(curInput.Tick, curInput.Tick);
                            continue;
                        }

                        uint changeMask = 0;
                        // These two new local variables can trigger stack overflow exceptions with exceptionally large ICommandData structs.
                        // Therefore, we add an upper size limit on the type itself. See test `ValuesAreSerialized_ICommandData`.
                        var snapshot = curInput;
                        var baseline = prevInput;
#region __GHOST_COMPARE_INPUTS__
#endregion

                        if (changeMask != 0u)
                            map.TryAdd(curInput.Tick, curInput.Tick);
                    }
                }
            }
        }
        private EntityQuery m_Query;
        private EntityQuery m_TickMapQuery;
        private BufferTypeHandle<__COMMAND_COMPONENT_TYPE__> m___COMMAND_NAME__Handle;
        [BurstCompile]
        public void OnCreate(ref SystemState state)
        {
            var builder = new EntityQueryBuilder(Allocator.Temp)
                .WithAllRW<__COMMAND_COMPONENT_TYPE__>();
            m_Query = state.GetEntityQuery(builder);
            builder.Reset();
            builder.WithAllRW<UniqueInputTickMap>();
            m_TickMapQuery = state.GetEntityQuery(builder);
            m___COMMAND_NAME__Handle = state.GetBufferTypeHandle<__COMMAND_COMPONENT_TYPE__>(true);
            state.RequireForUpdate(m_Query);
            state.RequireForUpdate<UniqueInputTickMap>();
        }
        [BurstCompile]
        public void OnUpdate(ref SystemState state)
        {
            m___COMMAND_NAME__Handle.Update(ref state);
            var job = new CompareJob
            {
                inputHandle = m___COMMAND_NAME__Handle,
                map = m_TickMapQuery.GetSingletonRW<UniqueInputTickMap>().ValueRO.Value
            };
            state.Dependency = job.ScheduleParallel(m_Query, state.Dependency);
        }
    }
}
