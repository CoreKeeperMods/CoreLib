
//------------------------------------------------------------------------------
// <auto-generated>
//     This file was automatically generated by Unity.Entities.Editor.BurstInteropCodeGenerator
//     Any changes you make here will be overwritten
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     To update this file, use the "DOTS -> Regenerate Burst Interop" menu option.
//
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;
using Unity.Collections;
using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.Entities
{
     unsafe partial struct ECBInterop
    {

        [BurstDiscard]
        private static void CheckDelegate(ref bool useDelegate)
        {
            //@TODO: This should use BurstCompiler.IsEnabled once that is available as an efficient API.
            useDelegate = true;
        }

        private static bool UseDelegate()
        {
            bool result = false;
            CheckDelegate(ref result);
            return result;
        }

        static class Managed
        {
            public static bool _initialized = false;

            public delegate void _dlg_ProcessChainChunk(IntPtr walker, int processorType, IntPtr chainStates, int currentChain, int nextChain);
            public static _dlg_ProcessChainChunk _bfp_ProcessChainChunk;
            public delegate void _dlg_RemoveManagedReferences(IntPtr mgr, IntPtr sharedIndex, int count);
            public static object _gcDefeat_RemoveManagedReferences;
            public delegate void _dlg_CleanupManaged(IntPtr chain);
            public static object _gcDefeat_CleanupManaged;
            public delegate void _dlg_ProcessManagedCommand(IntPtr processor, int processorType, IntPtr header);
            public static object _gcDefeat_ProcessManagedCommand;
        }

        struct TagType_RemoveManagedReferences {};
        public static readonly SharedStatic<IntPtr> _bfp_RemoveManagedReferences = SharedStatic<IntPtr>.GetOrCreate<TagType_RemoveManagedReferences>();
        struct TagType_CleanupManaged {};
        public static readonly SharedStatic<IntPtr> _bfp_CleanupManaged = SharedStatic<IntPtr>.GetOrCreate<TagType_CleanupManaged>();
        struct TagType_ProcessManagedCommand {};
        public static readonly SharedStatic<IntPtr> _bfp_ProcessManagedCommand = SharedStatic<IntPtr>.GetOrCreate<TagType_ProcessManagedCommand>();

        [ExcludeFromBurstCompatTesting("Uses managed delegates")]
        internal static void Initialize()
        {
            if (Managed._initialized)
                return;
            Managed._initialized = true;
            Managed._bfp_ProcessChainChunk = BurstCompiler.CompileFunctionPointer<Managed._dlg_ProcessChainChunk>(_mono_to_burst_ProcessChainChunk).Invoke;
        {
            Managed._dlg_RemoveManagedReferences delegateObject = _wrapper_RemoveManagedReferences;
            Managed._gcDefeat_RemoveManagedReferences = delegateObject;
            _bfp_RemoveManagedReferences.Data = Marshal.GetFunctionPointerForDelegate(delegateObject);
        }
        {
            Managed._dlg_CleanupManaged delegateObject = _wrapper_CleanupManaged;
            Managed._gcDefeat_CleanupManaged = delegateObject;
            _bfp_CleanupManaged.Data = Marshal.GetFunctionPointerForDelegate(delegateObject);
        }
        {
            Managed._dlg_ProcessManagedCommand delegateObject = _wrapper_ProcessManagedCommand;
            Managed._gcDefeat_ProcessManagedCommand = delegateObject;
            _bfp_ProcessManagedCommand.Data = Marshal.GetFunctionPointerForDelegate(delegateObject);
        }

        }

        internal  static void ProcessChainChunk (void* walker, int processorType, ECBChainPlaybackState* chainStates, int currentChain, int nextChain)
        {
            if (UseDelegate())
            {
                _forward_mono_ProcessChainChunk(walker, processorType, chainStates, currentChain, nextChain);
                return;
            }

            _ProcessChainChunk(walker, processorType, chainStates, currentChain, nextChain);
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(Managed._dlg_ProcessChainChunk))]
        private static void _mono_to_burst_ProcessChainChunk(IntPtr walker, int processorType, IntPtr chainStates, int currentChain, int nextChain)
        {
            _ProcessChainChunk((void*)walker, processorType, (ECBChainPlaybackState*)chainStates, currentChain, nextChain);
        }

        [BurstDiscard]
        private static void _forward_mono_ProcessChainChunk(void* walker, int processorType, ECBChainPlaybackState* chainStates, int currentChain, int nextChain)
        {
            Managed._bfp_ProcessChainChunk((IntPtr) walker, processorType, (IntPtr) chainStates, currentChain, nextChain);
        }


        internal static void RemoveManagedReferences (EntityDataAccess* mgr, int* sharedIndex, int count)
        {
            if (!UseDelegate())
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS || UNITY_DOTS_DEBUG
                if( _bfp_RemoveManagedReferences.Data == IntPtr.Zero)
                    throw new InvalidOperationException("Burst Interop Classes must be initialized manually");
#endif

                var fp = new FunctionPointer<Managed._dlg_RemoveManagedReferences>(_bfp_RemoveManagedReferences.Data);
                fp.Invoke((IntPtr) mgr, (IntPtr) sharedIndex, count);
                return;
            }
            _RemoveManagedReferences(mgr, sharedIndex, count);
        }

        [MonoPInvokeCallback(typeof(Managed._dlg_RemoveManagedReferences))]
        private static void _wrapper_RemoveManagedReferences (IntPtr mgr, IntPtr sharedIndex, int count)
        {
            _RemoveManagedReferences((EntityDataAccess*)mgr, (int*)sharedIndex, count);
        }
        internal static void CleanupManaged (EntityCommandBufferChain* chain)
        {
            if (!UseDelegate())
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS || UNITY_DOTS_DEBUG
                if( _bfp_CleanupManaged.Data == IntPtr.Zero)
                    throw new InvalidOperationException("Burst Interop Classes must be initialized manually");
#endif

                var fp = new FunctionPointer<Managed._dlg_CleanupManaged>(_bfp_CleanupManaged.Data);
                fp.Invoke((IntPtr) chain);
                return;
            }
            _CleanupManaged(chain);
        }

        [MonoPInvokeCallback(typeof(Managed._dlg_CleanupManaged))]
        private static void _wrapper_CleanupManaged (IntPtr chain)
        {
            _CleanupManaged((EntityCommandBufferChain*)chain);
        }
        internal static void ProcessManagedCommand (void* processor, int processorType, BasicCommand* header)
        {
            if (!UseDelegate())
            {
#if ENABLE_UNITY_COLLECTIONS_CHECKS || UNITY_DOTS_DEBUG
                if( _bfp_ProcessManagedCommand.Data == IntPtr.Zero)
                    throw new InvalidOperationException("Burst Interop Classes must be initialized manually");
#endif

                var fp = new FunctionPointer<Managed._dlg_ProcessManagedCommand>(_bfp_ProcessManagedCommand.Data);
                fp.Invoke((IntPtr) processor, processorType, (IntPtr) header);
                return;
            }
            _ProcessManagedCommand(processor, processorType, header);
        }

        [MonoPInvokeCallback(typeof(Managed._dlg_ProcessManagedCommand))]
        private static void _wrapper_ProcessManagedCommand (IntPtr processor, int processorType, IntPtr header)
        {
            _ProcessManagedCommand((void*)processor, processorType, (BasicCommand*)header);
        }


    }
}
